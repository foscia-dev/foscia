---
sidebar_position: 100
description: Define models with attributes, relations and hooks.
---

import Link from '@docusaurus/Link';
import TabItem from '@theme/TabItem';
import Tabs from '@theme/Tabs';
import ShellCommand from '@site/src/components/ShellCommand';

# Models

:::tip What you'll learn

- Defining basic models with attributes and relations
- Extending your models with custom properties
- Registering hooks on models

:::

## Before reading this guide

This guide is only about basic usages of models and definition of the model's
schema.
To learn more, you can:

- [Learn advanced capabilities of models in the dedicated digging deeper guides](/docs/category/models)
- [Discover models through examples](/docs/category/examples)

## Models

### Using CLI

You can generate a new model using [`@foscia/cli`](/docs/digging-deeper/usages/cli).

<ShellCommand command="foscia make model post" />

### Model factory

To declare a model, you just need to use the
[`makeModel`](/docs/api/@foscia/core/functions/makeModel) function.
This function takes up to 2 arguments and returns a
[`Model`](/docs/api/@foscia/core/type-aliases/Model) constructor:

- The `type` string or a
[configuration object](/docs/digging-deeper/models/models-configuration).
- The [optional `definition` of the model](#definition): an object
containing property definition factories, custom properties, custom
methods and composables.

```typescript
import { makeModel, attr, hasMany, toDateTime } from '@foscia/core';

export default makeModel('posts', {
  /* The model definition */
  title: attr<string>(),
  description: attr<string>(),
  publishedAt: attr(toDateTime()).nullable(),
  comments: hasMany(() => Comment),
  get published() {
    return !!this.publishedAt;
  },
});
```

### Extending a model class

[`makeModel`](/docs/api/@foscia/core/functions/makeModel) will return a
[`Model`](/docs/api/@foscia/core/type-aliases/Model) constructor
which can be extended by an ES6 class.

```typescript
export default class Post extends makeModel('posts') {}
```

The returned [`Model`](/docs/api/@foscia/core/type-aliases/Model) constructor
also implements [`ExtendableModel`](/docs/api/@foscia/core/type-aliases/ExtendableModel)
and provides static methods to extend the definition
already provided to [`makeModel`](/docs/api/@foscia/core/functions/makeModel).

```typescript
/* Initial model creation without definition */
export default makeModel('posts')
  .extend({
    title: attr<string>(),
    description: attr<string>(),
  })
  .extend({
    publishedAt: attr(toDateTime()),
    get published() {
      return !!this.publishedAt;
    },
  })
  .configure({
    /* ...configuration */
  });
```

This can be useful when sharing common features across models: creation
timestamps, client side ID generation, etc.

If you wish to learn more about the composition capabilities of models, you
should read the
[advanced guide about models composition](/docs/digging-deeper/models/models-composition).

:::info

Each call to `extend` or `configure` will return a child class of the
original model class.

:::

#### Note on exported value

In many Foscia guides and examples, you will see that the ES6 class returned by
[`makeModel`](/docs/api/@foscia/core/functions/makeModel) is extended before
exporting: we use `export default class Post extends makeModel...` instead of
`export default makeModel...`.

This has two benefits:

- When using TypeScript, it allows to only import the type of the class using
  `import type Post from './models/post'` and avoids circular dependencies when
  models have circular relationships
- It gives you more flexibility as you can quickly add custom properties and
  methods in the future

However, both syntax are valid. Use the one you prefer! ðŸ¦„

### Using models classes

Model classes can be used like any ES6 class. It can be instantiated,
manipulated, etc. Properties will be defined on each instance from the model
definition.

```typescript
const post = new Post();
post.title = 'Hello World!';
post.publishedAt = new Date();
console.log(post.title); // "Hello World!"
console.log(post.published); // true
console.log(post.$exists); // false
```

:::info

Please note that most model's interaction (fetching, updating, etc.) are done
through actions, you can
[**read the actions guide**](/docs/core-concepts/actions) to learn more about
those.

:::

### Utilities

Foscia provides multiple utilities functions to interact with models.

<Link className="button border--gradient" to="/docs/api/@foscia/core/#utilities">
  Models' utilities API reference
</Link>

## Definition

### IDs

#### Description

[`id`](/docs/api/@foscia/core/functions/id) is an ID definition factory used
to define your model's IDs properties.
You can pass a transformer or a default value to this factory.

- Foscia consider your IDs as `string`, `number` or `null` values by default.
  Each model have `id` and `lid` properties representing record identification.
  If you want to change the typing of those properties or transform values, you
  can use the `id` function.
- `id` properties can be transformed.
  [Read more on the transformers guide](/docs/digging-deeper/models/models-transformers).
- `id` definition factory supports [chained modifiers](#ids-chained-modifiers).

:::warning

`id` cannot use another type than `number`, `string` or `null` and can only be
used on `id` and `lid` keyed model's properties. There is currently no way of
aliasing an ID in Foscia.

[**Please fill an issue if this is something you need.**](https://github.com/foscia-dev/foscia/issues/new/choose)

:::

#### Examples

<Tabs>
<TabItem
  value="type"
  label="Type"
  default
>

```typescript
id<string>();
id<string | null>();
```

</TabItem>
<TabItem
  value="default"
  label="Default"
>

```typescript
id('');
id(() => uuidV4(), { readOnly: true });
```

</TabItem>
<TabItem
  value="transformer"
  label="Transformer"
>

```typescript
id(toString());
id(toString(), { readOnly: true });
```

</TabItem>
<TabItem
  value="chaining"
  label="Chaining"
>

```typescript
id<string>()
  .nullable()
  .default(() => null)
  .readOnly();
```

</TabItem>
</Tabs>

#### API {#ids-chained-modifiers}

[`id`](/docs/api/@foscia/core/functions/id) provides type definition
for the factory and examples.
[`ModelIdFactory`](/docs/api/@foscia/core/type-aliases/ModelIdFactory)
provides type definition of `id` chained modifiers.

### Attributes

#### Description

[`attr`](/docs/api/@foscia/core/functions/attr) is an attribute definition
factory used to define your model's
attributes. You can pass a transformer or a default value to this factory.

- Foscia consider your attributes as non-nullable values by default.
- Non-loaded attributes will have a value of `undefined`.
- `attr` properties can be transformed.
  [Read more on the transformers guide](/docs/digging-deeper/models/models-transformers).
- `attr` definition factory supports
  [chained modifiers](#attributes-chained-modifiers).

#### Examples

<Tabs>
<TabItem
  value="type"
  label="Type"
  default
>

```typescript
attr<string>();
attr<Date | null>();
```

</TabItem>
<TabItem
  value="default"
  label="Default"
>

```typescript
attr('');
attr(() => new Date(), { readOnly: true });
```

</TabItem>
<TabItem
  value="transformer"
  label="Transformer"
>

```typescript
attr(toString());
attr(toDateTime(), { readOnly: true });
```

</TabItem>
<TabItem
  value="chaining"
  label="Chaining"
>

```typescript
attr<Date>()
  .nullable()
  .default(() => null)
  .readOnly();
```

</TabItem>
</Tabs>

#### API {#attributes-chained-modifiers}

[`attr`](/docs/api/@foscia/core/functions/attr) provides type definition
for the factory and examples.
[`ModelAttributeFactory`](/docs/api/@foscia/core/type-aliases/ModelAttributeFactory)
provides type definition of `attr` chained modifiers.

### Relations

#### Description

[`hasMany`](/docs/api/@foscia/core/functions/hasMany) and
[`hasOne`](/docs/api/@foscia/core/functions/hasOne) are relation
definition factories used to define your model's relations.
As suggested by their names, `hasMany` represents a
relation to a list of models and `hasOne` represents a relation to a single
model. You can pass the relation information to this factory.

- Foscia consider your relations as non-nullable values by default.
- Non-loaded relations will have a value of `undefined`.
- `hasOne` and `hasMany` definition factories supports
  [chained modifiers](#relations-chained-modifiers).
- Depending on your data structure, you should follow one of the recommandation
  over relations definition to avoid circular dependencies errors:
  - [Explicit **model** when **not having circular dependencies**](#explicit-model-when-not-having-circular-references).
  - [Explicit **type** when **having circular dependencies**](#explicit-type-when-having-circular-references).

#### Examples

<Tabs>
<TabItem
  value="hasOne"
  label="hasOne"
  default
>

<Tabs>
<TabItem
  value="model"
  label="Model"
  default
>

```typescript
hasOne(() => User);
hasOne(() => User, { readOnly: true });
```

</TabItem>
<TabItem
  value="type"
  label="Type"
>

```typescript
hasOne<User>();
hasOne<User>('users');
```

</TabItem>
<TabItem
  value="polymorphism"
  label="Polymorphism"
>

```typescript
hasOne(() => [Comment, Post]);
hasOne<Comment | Post>(['comments', 'posts']);
```

</TabItem>
<TabItem
  value="config"
  label="Config"
>

```typescript
hasMany(() => User, { path: 'author' });
hasMany<User>({ path: 'author' });
```

</TabItem>
<TabItem
  value="chaining"
  label="Chaining"
>

```typescript
hasOne(() => User)
  .nullable()
  .readOnly()
  .alias('author')
  .sync('pull');
```

</TabItem>
</Tabs>

</TabItem>
<TabItem
  value="hasMany"
  label="hasMany"
>

<Tabs>
<TabItem
  value="model"
  label="Model"
  default
>

```typescript
hasMany(() => Comment);
hasMany(() => Comment, { readOnly: true });
```

</TabItem>
<TabItem
  value="type"
  label="Type"
>

```typescript
hasMany<Comment[]>();
hasMany<Comment[]>('comments');
```

</TabItem>
<TabItem
  value="polymorphism"
  label="Polymorphism"
>

```typescript
hasMany(() => [Comment, Post]);
hasMany<(Comment | Post)[]>(['comments', 'posts']);
```

</TabItem>
<TabItem
  value="config"
  label="Config"
>

```typescript
hasMany(() => Comment, { path: 'top-comments' });
hasMany<Comment[]>({ path: 'top-comments' });
```

</TabItem>
<TabItem
  value="chaining"
  label="Chaining"
>

```typescript
hasMany(() => Comment)
  .readOnly()
  .sync('pull');
```

</TabItem>
</Tabs>

</TabItem>
</Tabs>

#### API {#relations-chained-modifiers}

[`hasOne`](/docs/api/@foscia/core/functions/hasOne) and
[`hasMany`](/docs/api/@foscia/core/functions/hasMany) provide type definition
for the factories and examples.
[`ModelRelationFactory`](/docs/api/@foscia/core/type-aliases/ModelRelationFactory)
provides type definition of `hasOne` and `hasMany` chained modifiers.

#### Polymorphism support

Polymorphism may require a specific configuration of your action or your data
source.

For example, polymorphism is supported out of the box with JSON:API, because
each record have a special `type` property which is resolved by Foscia to the
correct model.

When implementing polymorphism with a REST data source, your record JSON object
must contain a `type` property matching your Foscia models' types.

#### Recommandations

##### Explicit model when not having circular references

If your models does not contain ciruclar references (e.g. Post has a "author"
relation to User and User has a "favoritePosts" relation to Post), you should
define your relations with explicit related model as follow:

```typescript
import { hasOne } from '@foscia/core';
import User from './user';

hasOne(() => User);
```

This will make identifying a relation's related model easier for Foscia and make
registering your models optional.

##### Explicit type when having circular references

If your models does contain ciruclar references (e.g. Post has a "author"
relation to User and User has a "favoritePosts" relation to Post), you should
define your relations with a TypeScript type as follow:

```typescript
import { hasOne } from '@foscia/core';
import type User from './user';

hasOne<User>();
```

Notice the `import type` for type definition when using TypeScript. This will
import the type of the model and will avoid circular dependencies at runtime.

You should also
[correctly register your models](/docs/digging-deeper/actions/models-registration)
on your action factory registry.

When using a data source where each record contains an explicit type info (e.g.
JSON:API), you don't have anything to do.

If your data source does not provide an explicit type info, you should either:

- Let Foscia guess the related type from the relation's name.
- Add an explicit mapped type to the relation as follow:

```typescript
import { hasOne } from '@foscia/core';
import type User from './user';

hasOne<User>('users');
```

### Custom properties

In addition to IDs, attributes and relations, you can implement additional
properties to your model. It's useful when you need computed values (getters) or
specific instance methods.

This can be done using the definition or an extending class:

```typescript
// Directly in the definition.
export default makeModel('users', {
  firstName: attr(toString()),
  lastName: attr(toString()),
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  },
});

// Inside an extending class.
export default class User extends makeModel('users', {
  firstName: attr(toString()),
  lastName: attr(toString()),
}) {
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
```

## Special properties

Foscia models provide special properties on both the model class and its
instances, which you can discover inside the API reference:

- [`Model`](/docs/api/@foscia/core/type-aliases/Model)
- [`ModelInstance`](/docs/api/@foscia/core/type-aliases/ModelInstance)
